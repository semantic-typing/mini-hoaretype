
** Conflict (shift/reduce) in state 228.
** Token involved: PIPE
** This state is reached from program after reading:

MATCH expr WITH PIPE pattern ARROW MATCH expr WITH match_branch

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
match_expr 
MATCH expr WITH match_branches 
                (?)

** In state 228, looking ahead at PIPE, shifting is permitted
** because of the following sub-derivation:

match_branch 
PIPE pattern ARROW expr 
                   match_expr 
                   MATCH expr WITH match_branches 
                                   match_branch match_branches 
                                                match_branch 
                                                . PIPE pattern ARROW expr 

** In state 228, looking ahead at PIPE, reducing production
** match_branches -> match_branch
** is permitted because of the following sub-derivation:

match_branch match_branches // lookahead token appears because match_branches can begin with PIPE
PIPE pattern ARROW expr // lookahead token is inherited
                   match_expr // lookahead token is inherited
                   MATCH expr WITH match_branches // lookahead token is inherited
                                   match_branch . 

** Conflict (reduce/reduce) in state 212.
** Token involved: SEMICOLON
** This state is reached from program after reading:

LET IDENT ASSIGN expr IN LET IDENT ASSIGN expr IN block_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
(?)

** In state 212, looking ahead at SEMICOLON, reducing production
** expr -> LET IDENT ASSIGN expr IN block_expr
** is permitted because of the following sub-derivation:

stmt_list EOF 
stmt SEMICOLON stmt_list // lookahead token appears
let_stmt // lookahead token is inherited
LET IDENT ASSIGN expr IN block_expr // lookahead token is inherited
                         expr // lookahead token is inherited
                         LET IDENT ASSIGN expr IN block_expr . 

** In state 212, looking ahead at SEMICOLON, reducing production
** let_stmt -> LET IDENT ASSIGN expr IN block_expr
** is permitted because of the following sub-derivation:

expr EOF 
LET IDENT ASSIGN expr IN block_expr 
                         block_body 
                         stmt SEMICOLON block_body // lookahead token appears
                         let_stmt // lookahead token is inherited
                         LET IDENT ASSIGN expr IN block_expr . 

** Conflict (reduce/reduce) in state 202.
** Tokens involved: WITH THEN SEMICOLON RPAREN RBRACKET RBRACE PIPE IN EOF ELSE DO COMMA
** The following explanations concentrate on token SEMICOLON.
** This state is reached from program after reading:

LET IDENT ASSIGN expr IN expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
stmt_list EOF 
stmt SEMICOLON stmt_list // lookahead token appears
let_stmt // lookahead token is inherited
LET IDENT ASSIGN expr IN block_expr // lookahead token is inherited
                         (?)

** In state 202, looking ahead at SEMICOLON, reducing production
** block_body -> expr
** is permitted because of the following sub-derivation:

block_body // lookahead token is inherited
expr . 

** In state 202, looking ahead at SEMICOLON, reducing production
** block_expr -> expr
** is permitted because of the following sub-derivation:

expr . 

** Conflict (shift/reduce) in state 171.
** Tokens involved: PIPE ARROW AND
** The following explanations concentrate on token PIPE.
** This state is reached from program after reading:

DATA IDENT ASSIGN IDENT LPAREN NOT type_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
stmt_list EOF 
stmt SEMICOLON stmt_list 
data_def 
DATA IDENT ASSIGN constructor_defs 
                  constructor_def 
                  IDENT LPAREN type_list RPAREN 
                               type_expr 
                               (?)

** In state 171, looking ahead at PIPE, shifting is permitted
** because of the following sub-derivation:

NOT type_expr 
    type_expr . PIPE type_expr 

** In state 171, looking ahead at PIPE, reducing production
** type_expr -> NOT type_expr
** is permitted because of the following sub-derivation:

type_expr PIPE type_expr // lookahead token appears
NOT type_expr . 

** Conflict (shift/reduce) in state 165.
** Tokens involved: PIPE ARROW AND
** The following explanations concentrate on token PIPE.
** This state is reached from program after reading:

DATA IDENT ASSIGN IDENT LPAREN type_expr AND type_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
stmt_list EOF 
stmt SEMICOLON stmt_list 
data_def 
DATA IDENT ASSIGN constructor_defs 
                  constructor_def 
                  IDENT LPAREN type_list RPAREN 
                               type_expr 
                               (?)

** In state 165, looking ahead at PIPE, shifting is permitted
** because of the following sub-derivation:

type_expr AND type_expr 
              type_expr . PIPE type_expr 

** In state 165, looking ahead at PIPE, reducing production
** type_expr -> type_expr AND type_expr
** is permitted because of the following sub-derivation:

type_expr PIPE type_expr // lookahead token appears
type_expr AND type_expr . 

** Conflict (shift/reduce) in state 163.
** Tokens involved: PIPE ARROW AND
** The following explanations concentrate on token PIPE.
** This state is reached from program after reading:

DATA IDENT ASSIGN IDENT LPAREN type_expr ARROW type_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
stmt_list EOF 
stmt SEMICOLON stmt_list 
data_def 
DATA IDENT ASSIGN constructor_defs 
                  constructor_def 
                  IDENT LPAREN type_list RPAREN 
                               type_expr 
                               (?)

** In state 163, looking ahead at PIPE, reducing production
** type_expr -> type_expr ARROW type_expr
** is permitted because of the following sub-derivation:

type_expr PIPE type_expr // lookahead token appears
type_expr ARROW type_expr . 

** In state 163, looking ahead at PIPE, shifting is permitted
** because of the following sub-derivation:

type_expr ARROW type_expr 
                type_expr . PIPE type_expr 

** Conflict (shift/reduce) in state 161.
** Tokens involved: PIPE ARROW AND
** The following explanations concentrate on token PIPE.
** This state is reached from program after reading:

DATA IDENT ASSIGN IDENT LPAREN type_expr PIPE type_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
stmt_list EOF 
stmt SEMICOLON stmt_list 
data_def 
DATA IDENT ASSIGN constructor_defs 
                  constructor_def 
                  IDENT LPAREN type_list RPAREN 
                               type_expr 
                               (?)

** In state 161, looking ahead at PIPE, shifting is permitted
** because of the following sub-derivation:

type_expr PIPE type_expr 
               type_expr . PIPE type_expr 

** In state 161, looking ahead at PIPE, reducing production
** type_expr -> type_expr PIPE type_expr
** is permitted because of the following sub-derivation:

type_expr PIPE type_expr // lookahead token appears
type_expr PIPE type_expr . 

** Conflict (reduce/reduce) in state 150.
** Tokens involved: TIMES RPAREN PIPE ARROW AND
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

DATA IDENT ASSIGN IDENT LPAREN IDENT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
stmt_list EOF 
stmt SEMICOLON stmt_list 
data_def 
DATA IDENT ASSIGN constructor_defs 
                  constructor_def 
                  IDENT LPAREN type_list RPAREN 
                               type_expr TIMES type_list // lookahead token appears
                               (?)

** In state 150, looking ahead at TIMES, reducing production
** constructor_type -> IDENT
** is permitted because of the following sub-derivation:

constructor_type // lookahead token is inherited
IDENT . 

** In state 150, looking ahead at TIMES, reducing production
** type_expr -> IDENT
** is permitted because of the following sub-derivation:

IDENT . 

** Conflict (shift/reduce) in state 82.
** Tokens involved: TIMES POW PLUS OR NEQ MOD MINUS LT LE GT GE EQ DIV AND
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

bin_expr AND bin_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
bin_expr 
(?)

** In state 82, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

bin_expr AND bin_expr 
             bin_expr . TIMES bin_expr 

** In state 82, looking ahead at TIMES, reducing production
** bin_expr -> bin_expr AND bin_expr
** is permitted because of the following sub-derivation:

bin_expr TIMES bin_expr // lookahead token appears
bin_expr AND bin_expr . 

** Conflict (shift/reduce) in state 80.
** Tokens involved: TIMES POW PLUS OR NEQ MOD MINUS LT LE GT GE EQ DIV AND
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

bin_expr DIV bin_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
bin_expr 
(?)

** In state 80, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

bin_expr DIV bin_expr 
             bin_expr . TIMES bin_expr 

** In state 80, looking ahead at TIMES, reducing production
** bin_expr -> bin_expr DIV bin_expr
** is permitted because of the following sub-derivation:

bin_expr TIMES bin_expr // lookahead token appears
bin_expr DIV bin_expr . 

** Conflict (shift/reduce) in state 78.
** Tokens involved: TIMES POW PLUS OR NEQ MOD MINUS LT LE GT GE EQ DIV AND
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

bin_expr EQ bin_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
bin_expr 
(?)

** In state 78, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

bin_expr EQ bin_expr 
            bin_expr . TIMES bin_expr 

** In state 78, looking ahead at TIMES, reducing production
** bin_expr -> bin_expr EQ bin_expr
** is permitted because of the following sub-derivation:

bin_expr TIMES bin_expr // lookahead token appears
bin_expr EQ bin_expr . 

** Conflict (shift/reduce) in state 76.
** Tokens involved: TIMES POW PLUS OR NEQ MOD MINUS LT LE GT GE EQ DIV AND
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

bin_expr GE bin_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
bin_expr 
(?)

** In state 76, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

bin_expr GE bin_expr 
            bin_expr . TIMES bin_expr 

** In state 76, looking ahead at TIMES, reducing production
** bin_expr -> bin_expr GE bin_expr
** is permitted because of the following sub-derivation:

bin_expr TIMES bin_expr // lookahead token appears
bin_expr GE bin_expr . 

** Conflict (shift/reduce) in state 74.
** Tokens involved: TIMES POW PLUS OR NEQ MOD MINUS LT LE GT GE EQ DIV AND
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

bin_expr GT bin_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
bin_expr 
(?)

** In state 74, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

bin_expr GT bin_expr 
            bin_expr . TIMES bin_expr 

** In state 74, looking ahead at TIMES, reducing production
** bin_expr -> bin_expr GT bin_expr
** is permitted because of the following sub-derivation:

bin_expr TIMES bin_expr // lookahead token appears
bin_expr GT bin_expr . 

** Conflict (shift/reduce) in state 72.
** Tokens involved: TIMES POW PLUS OR NEQ MOD MINUS LT LE GT GE EQ DIV AND
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

bin_expr LE bin_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
bin_expr 
(?)

** In state 72, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

bin_expr LE bin_expr 
            bin_expr . TIMES bin_expr 

** In state 72, looking ahead at TIMES, reducing production
** bin_expr -> bin_expr LE bin_expr
** is permitted because of the following sub-derivation:

bin_expr TIMES bin_expr // lookahead token appears
bin_expr LE bin_expr . 

** Conflict (shift/reduce) in state 70.
** Tokens involved: TIMES POW PLUS OR NEQ MOD MINUS LT LE GT GE EQ DIV AND
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

bin_expr LT bin_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
bin_expr 
(?)

** In state 70, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

bin_expr LT bin_expr 
            bin_expr . TIMES bin_expr 

** In state 70, looking ahead at TIMES, reducing production
** bin_expr -> bin_expr LT bin_expr
** is permitted because of the following sub-derivation:

bin_expr TIMES bin_expr // lookahead token appears
bin_expr LT bin_expr . 

** Conflict (shift/reduce) in state 68.
** Tokens involved: TIMES POW PLUS OR NEQ MOD MINUS LT LE GT GE EQ DIV AND
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

bin_expr MINUS bin_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
bin_expr 
(?)

** In state 68, looking ahead at TIMES, reducing production
** bin_expr -> bin_expr MINUS bin_expr
** is permitted because of the following sub-derivation:

bin_expr TIMES bin_expr // lookahead token appears
bin_expr MINUS bin_expr . 

** In state 68, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

bin_expr MINUS bin_expr 
               bin_expr . TIMES bin_expr 

** Conflict (shift/reduce) in state 66.
** Tokens involved: TIMES POW PLUS OR NEQ MOD MINUS LT LE GT GE EQ DIV AND
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

bin_expr MOD bin_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
bin_expr 
(?)

** In state 66, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

bin_expr MOD bin_expr 
             bin_expr . TIMES bin_expr 

** In state 66, looking ahead at TIMES, reducing production
** bin_expr -> bin_expr MOD bin_expr
** is permitted because of the following sub-derivation:

bin_expr TIMES bin_expr // lookahead token appears
bin_expr MOD bin_expr . 

** Conflict (shift/reduce) in state 64.
** Tokens involved: TIMES POW PLUS OR NEQ MOD MINUS LT LE GT GE EQ DIV AND
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

bin_expr NEQ bin_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
bin_expr 
(?)

** In state 64, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

bin_expr NEQ bin_expr 
             bin_expr . TIMES bin_expr 

** In state 64, looking ahead at TIMES, reducing production
** bin_expr -> bin_expr NEQ bin_expr
** is permitted because of the following sub-derivation:

bin_expr TIMES bin_expr // lookahead token appears
bin_expr NEQ bin_expr . 

** Conflict (shift/reduce) in state 62.
** Tokens involved: TIMES POW PLUS OR NEQ MOD MINUS LT LE GT GE EQ DIV AND
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

bin_expr OR bin_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
bin_expr 
(?)

** In state 62, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

bin_expr OR bin_expr 
            bin_expr . TIMES bin_expr 

** In state 62, looking ahead at TIMES, reducing production
** bin_expr -> bin_expr OR bin_expr
** is permitted because of the following sub-derivation:

bin_expr TIMES bin_expr // lookahead token appears
bin_expr OR bin_expr . 

** Conflict (shift/reduce) in state 60.
** Tokens involved: TIMES POW PLUS OR NEQ MOD MINUS LT LE GT GE EQ DIV AND
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

bin_expr PLUS bin_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
bin_expr 
(?)

** In state 60, looking ahead at TIMES, reducing production
** bin_expr -> bin_expr PLUS bin_expr
** is permitted because of the following sub-derivation:

bin_expr TIMES bin_expr // lookahead token appears
bin_expr PLUS bin_expr . 

** In state 60, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

bin_expr PLUS bin_expr 
              bin_expr . TIMES bin_expr 

** Conflict (shift/reduce) in state 58.
** Tokens involved: TIMES POW PLUS OR NEQ MOD MINUS LT LE GT GE EQ DIV AND
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

bin_expr POW bin_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
bin_expr 
(?)

** In state 58, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

bin_expr POW bin_expr 
             bin_expr . TIMES bin_expr 

** In state 58, looking ahead at TIMES, reducing production
** bin_expr -> bin_expr POW bin_expr
** is permitted because of the following sub-derivation:

bin_expr TIMES bin_expr // lookahead token appears
bin_expr POW bin_expr . 

** Conflict (shift/reduce) in state 56.
** Tokens involved: TIMES POW PLUS OR NEQ MOD MINUS LT LE GT GE EQ DIV AND
** The following explanations concentrate on token TIMES.
** This state is reached from program after reading:

bin_expr TIMES bin_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
bin_expr 
(?)

** In state 56, looking ahead at TIMES, shifting is permitted
** because of the following sub-derivation:

bin_expr TIMES bin_expr 
               bin_expr . TIMES bin_expr 

** In state 56, looking ahead at TIMES, reducing production
** bin_expr -> bin_expr TIMES bin_expr
** is permitted because of the following sub-derivation:

bin_expr TIMES bin_expr // lookahead token appears
bin_expr TIMES bin_expr . 

** Conflict (shift/reduce) in state 41.
** Token involved: RPAREN
** This state is reached from program after reading:

primary_expr LPAREN expr COMMA expr_list

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
app_expr 
(?)

** In state 41, looking ahead at RPAREN, reducing production
** expr_list -> expr COMMA expr_list
** is permitted because of the following sub-derivation:

primary_expr LPAREN expr_list RPAREN // lookahead token appears
                    expr COMMA expr_list . 

** In state 41, looking ahead at RPAREN, shifting is permitted
** because of the following sub-derivation:

primary_expr primary_expr 
             tuple_expr 
             LPAREN expr COMMA expr_list . RPAREN 

** Conflict (shift/reduce) in state 38.
** Token involved: RPAREN
** This state is reached from program after reading:

primary_expr LPAREN expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF 
app_expr 
(?)

** In state 38, looking ahead at RPAREN, reducing production
** expr_list -> expr
** is permitted because of the following sub-derivation:

primary_expr LPAREN expr_list RPAREN // lookahead token appears
                    expr . 

** In state 38, looking ahead at RPAREN, shifting is permitted
** because of the following sub-derivation:

primary_expr primary_expr 
             LPAREN expr . RPAREN 

** Conflict (reduce/reduce) in state 29.
** Tokens involved: WITH THEN SEMICOLON RPAREN RBRACKET RBRACE PIPE IN EOF ELSE DO COMMA
** The following explanations concentrate on token EOF.
** This state is reached from program after reading:

primary_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF // lookahead token appears
(?)

** In state 29, looking ahead at EOF, reducing production
** expr -> primary_expr
** is permitted because of the following sub-derivation:

primary_expr . 

** In state 29, looking ahead at EOF, reducing production
** unary_expr -> primary_expr
** is permitted because of the following sub-derivation:

unary_expr // lookahead token is inherited
primary_expr . 

** Conflict (reduce/reduce) in state 26.
** Tokens involved: WITH THEN SEMICOLON RPAREN RBRACKET RBRACE PIPE IN EOF ELSE DO COMMA
** The following explanations concentrate on token EOF.
** This state is reached from program after reading:

unary_expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
expr EOF // lookahead token appears
(?)

** In state 26, looking ahead at EOF, reducing production
** bin_expr -> unary_expr
** is permitted because of the following sub-derivation:

bin_expr // lookahead token is inherited
unary_expr . 

** In state 26, looking ahead at EOF, reducing production
** expr -> unary_expr
** is permitted because of the following sub-derivation:

unary_expr . 
